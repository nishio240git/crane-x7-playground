#!/usr/bin/env python3
"""
軌道計画（Motion Planning / Trajectory Planning）の詳細説明
"""

print("=" * 80)
print("軌道計画とは何か")
print("=" * 80)

print("""
【軌道計画（Motion Planning / Trajectory Planning）とは】

ロボットが現在位置から目標位置まで移動するための
「経路と時間の計画」を立てること。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 従来のロボット制御での軌道計画
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
""")

print("""
【例】コップを掴むタスク

ステップ1: 物体認識・位置推定
━━━━━━━━━━━━━━━━━━━━━
  カメラ画像 → CV処理
  → コップの位置: (x=0.3m, y=0.2m, z=0.1m)

ステップ2: 逆運動学（Inverse Kinematics, IK）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  目標EEF位置 → 関節角度を計算
  例: (x, y, z) → (θ1, θ2, θ3, θ4, θ5, θ6, θ7)

ステップ3: 軌道計画 ← これ！
━━━━━━━━━━━━━━━━━━━━━━
  現在位置 A → 目標位置 B へどう移動するか？

  【考慮事項】
  ✓ 障害物回避（テーブル、壁、他の物体）
  ✓ 関節制限（各関節の可動範囲）
  ✓ 特異点回避（IKが解けない姿勢）
  ✓ 滑らかさ（急激な動きを避ける）
  ✓ 最短/最速経路
  ✓ エネルギー効率

  【出力】
  時刻 t=0.0s: 関節角度 [θ1_0, θ2_0, ..., θ7_0]
  時刻 t=0.1s: 関節角度 [θ1_1, θ2_1, ..., θ7_1]
  時刻 t=0.2s: 関節角度 [θ1_2, θ2_2, ..., θ7_2]
  ...
  時刻 t=3.0s: 関節角度 [θ1_30, θ2_30, ..., θ7_30] ← 目標到達

ステップ4: 制御
━━━━━━━━━━━━━━━━━━━━━━
  計画した軌道に沿ってモーターを制御
""")

print("\n" + "=" * 80)
print("2. 代表的な軌道計画アルゴリズム")
print("=" * 80)

print("""
【RRT (Rapidly-exploring Random Tree)】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ランダムサンプリングで木構造を成長させる

  動作:
    1. 現在位置から始める
    2. ランダムな方向にノードを追加
    3. 障害物に当たらないか確認
    4. 目標に到達するまで繰り返し

  特徴:
    ✓ 高次元空間でも動作
    ✓ 確率的完全性（時間をかければ必ず解を発見）
    ⚠ 経路が不自然（ジグザグ）
    ⚠ 計算時間が予測不能

【RRT* (RRT Star)】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  RRTの改良版、経路を最適化

  特徴:
    ✓ 最適性保証（漸近的最適）
    ✓ より滑らかな経路
    ⚠ 計算コスト高い

【PRM (Probabilistic Roadmap)】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  事前にロードマップを構築

  動作:
    1. 空間にランダムなノードを配置
    2. 衝突しないエッジで接続
    3. クエリ時はロードマップ上で探索

  特徴:
    ✓ 事前計算で高速化
    ✓ 複数クエリに対応
    ⚠ 事前計算が必要

【A* / Dijkstra】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  グラフ探索アルゴリズム

  特徴:
    ✓ 最短経路保証
    ✓ 決定的
    ⚠ 高次元では計算爆発
    ⚠ 離散化が必要

【MoveIt! (ROS)】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ROSの統合軌道計画フレームワーク

  内部で使用:
    - OMPL (Open Motion Planning Library)
    - RRT, RRT*, PRM, KPIECE, etc.
  
  機能:
    ✓ 衝突検出
    ✓ 複数プランナーの切り替え
    ✓ 可視化ツール
""")

print("\n" + "=" * 80)
print("3. 軌道計画の具体例（視覚化）")
print("=" * 80)

print("""
【シーン】テーブル上のコップを掴む

  目標
    ↓
   🥤
  ────────  ← テーブル（障害物）
    
  🤖 ← 現在位置（ロボット）

【直線移動（ナイーブ）】
  🤖 ----→ 🥤
      ↑ テーブルに衝突！NG

【軌道計画による経路】
  🤖 
   ↑
   |  ← 上に移動
   |
   └→→ ← 横に移動
      ↓
     🥤 ← 下に移動して掴む
  ────────
  
  3つのウェイポイント（経由点）:
    1. 現在位置 → 上へ
    2. 上       → 横へ
    3. 横       → 下へ（コップ）

【実際の軌道】
  各関節の角度を時間の関数として計算:
  
  θ1(t) = θ1_start + (θ1_end - θ1_start) * s(t)
  
  s(t): 補間関数（例：5次多項式）
        → 滑らかな加速・減速を実現
""")

print("\n" + "=" * 80)
print("4. Octo vs 従来の軌道計画")
print("=" * 80)

print("""
【従来のアプローチ（明示的軌道計画）】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  1. 画像認識 → 物体位置 (0.3m, 0.2m, 0.1m)
  2. IK計算   → 目標関節角
  3. 軌道計画 → 経路生成（RRT等）
  4. 制御     → モーター駆動

  長所:
    ✓ 解釈可能（デバッグしやすい）
    ✓ 安全性の保証（数学的に証明可能）
    ✓ 精密な制御

  短所:
    ✗ 各ステップでエラーが累積
    ✗ 計算コスト高い（リアルタイム性低い）
    ✗ 環境モデルが必要（すべての障害物を知る必要）
    ✗ 未知の状況に弱い
    ✗ 新しいロボットには再調整が必要

【Octoのアプローチ（End-to-End、暗黙的）】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  画像 → Transformer → アクション（直接）

  長所:
    ✓ 計算が速い（推論のみ）
    ✓ エラー累積なし
    ✓ 環境モデル不要
    ✓ 未知の状況に強い（汎化性能）
    ✓ 複数ロボットで共通モデル

  短所:
    ✗ ブラックボックス（内部動作が見えない）
    ✗ 安全性保証が難しい
    ✗ 学習に大量データが必要

【比較表】
┌──────────────┬────────────────┬────────────────┐
│ 項目         │ 従来（軌道計画）│ Octo (E2E)     │
├──────────────┼────────────────┼────────────────┤
│ 計算速度     │ 遅い（秒単位）  │ 速い（ms単位） │
│ データ要件   │ 少ない          │ 大量必要       │
│ 汎化性       │ 低い            │ 高い           │
│ 解釈可能性   │ 高い            │ 低い           │
│ 安全性保証   │ 可能            │ 難しい         │
│ 新環境適応   │ 難しい          │ 容易           │
└──────────────┴────────────────┴────────────────┘
""")

print("\n" + "=" * 80)
print("5. ハイブリッドアプローチ（最新研究）")
print("=" * 80)

print("""
【最新のトレンド】

End-to-Endの強み + 従来手法の安全性

例1: Octo with Safety Layer
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Octo → アクション提案
    ↓
  安全性チェック（軌道計画）
    ↓
  安全なら実行、危険なら修正

例2: Residual Learning
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  軌道計画 → ベースライン経路
    +
  Octo     → 修正量（residual）
    =
  最終アクション

例3: MPC + Learning
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Octo → 短期的なアクション
  MPC  → 長期的な制約充足
""")

print("\n" + "=" * 80)
print("6. Crane-X7での実装の選択肢")
print("=" * 80)

print("""
【Option 1】Octo のみ（推奨スタート）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  obs → Octo → action → ロボット制御

  実装:
    簡単、軽量、高速

  適用:
    - 安全な環境
    - テーブル上の操作
    - データが豊富なタスク

【Option 2】Octo + MoveIt!（安全重視）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  obs → Octo → 目標位置
               ↓
            MoveIt! → 軌道計画 → ロボット

  実装:
    やや複雑、MoveIt!の設定が必要

  適用:
    - 障害物が多い
    - 安全性が重要
    - 精密な軌道が必要

【Option 3】Octo + Safety Filter（バランス）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  obs → Octo → action
               ↓
           安全性チェック → OK/NG
               ↓
            ロボット

  実装:
    中程度、簡単な衝突検出

  適用:
    - ほとんどのケース
    - 実用的なバランス
""")

print("\n" + "=" * 80)
print("【まとめ】")
print("=" * 80)

print("""
【軌道計画とは】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  現在位置 → 目標位置への
  「経路と時間の計画」

  考慮事項:
    - 障害物回避
    - 関節制限
    - 滑らかさ
    - 最適性

【Octoとの関係】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  従来: 明示的に軌道を計算
  Octo: 暗黙的にTransformerが学習
        （明示的な軌道計画なし）

【Crane-X7での推奨】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  1. まずOctoのみで試す
  2. 必要に応じて安全機構を追加
  3. 複雑な環境では MoveIt! 併用も検討
""")

print("\n分析完了")
